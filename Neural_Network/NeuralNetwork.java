import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.io.PrintWriter;
import java.util.Scanner;
import java.util.Arrays;
import java.util.List;
import java.io.File;

public class NeuralNetwork {
    private static BasicUtils U = new BasicUtils();
    
    Matrix weights_ih, weights_ho, bias_h, bias_o;
    double l_rate = 0.01;
    boolean useMultiThreading = false;

    public NeuralNetwork(int i, int h, int o) {
        weights_ih = new Matrix(h, i);
        weights_ho = new Matrix(o, h);

        bias_h = new Matrix(h, 1);
        bias_o = new Matrix(o, 1);
    }

    public NeuralNetwork(int i, int h, int o, boolean useMultiThreading) {
        weights_ih = new Matrix(h, i);
        weights_ho = new Matrix(o, h);

        bias_h = new Matrix(h, 1);
        bias_o = new Matrix(o, 1);

        this.useMultiThreading = useMultiThreading;
    }

    public NeuralNetwork(int i, int h, int o, double l_rate) {
        weights_ih = new Matrix(h, i);
        weights_ho = new Matrix(o, h);

        bias_h = new Matrix(h, 1);
        bias_o = new Matrix(o, 1);

        this.l_rate = l_rate;
    }

    public NeuralNetwork(int i, int h, int o, double l_rate, boolean useMultiThreading) {
        weights_ih = new Matrix(h, i);
        weights_ho = new Matrix(o, h);

        bias_h = new Matrix(h, 1);
        bias_o = new Matrix(o, 1);

        this.l_rate = l_rate;
        this.useMultiThreading = useMultiThreading;
    }

    public List<Double> predict(double[] X) {
        Matrix input = Matrix.fromArray(X);
        Matrix hidden = Matrix.multiply(weights_ih, input, useMultiThreading);
        hidden.add(bias_h);
        hidden.sigmoid();

        Matrix output = Matrix.multiply(weights_ho, hidden, useMultiThreading);
        output.add(bias_o);
        output.sigmoid();

        return output.toArray();
    }

    public void fit(double[][] X, double[][] Y, int epochs) {
        for (int i = 0; i < epochs; i++) {
            int sampleN = (int) (Math.random() * X.length);
            this.train(X[sampleN], Y[sampleN], false);
        }
    }

    public void fit(double[][] X, double[][] Y, int epochs, int verbose) {
        switch (verbose) {

            case 0: {
                U.println("Staring training with " + epochs + " epochs");
                long start = System.currentTimeMillis();
                for (int i = 0; i < epochs; i++) {
                    int sampleN = (int) (Math.random() * X.length);
                    this.train(X[sampleN], Y[sampleN], i + 1 == epochs);
                }
                long end = System.currentTimeMillis();
                long elapsedTime = end - start;
                U.println("Training took : " + (elapsedTime / 1000) + "s\n");

                break;
            }

            case 1: {
                U.println("Staring training with " + epochs + " epochs");
                long start = System.currentTimeMillis();
                for (int i = 0; i < epochs; i++) {
                    U.println("Epoch: " + (i + 1));
                    int sampleN = (int) (Math.random() * X.length);
                    this.train(X[sampleN], Y[sampleN], true);
                }
                long end = System.currentTimeMillis();
                long elapsedTime = end - start;
                U.println("Training took : " + (elapsedTime / 1000) + "s");

                break;
            }
        }
    }

    public void train(double[] X, double[] Y, Boolean showLoss) {
        Matrix input = Matrix.fromArray(X);
        Matrix hidden = Matrix.multiply(weights_ih, input, useMultiThreading);
        hidden.add(bias_h);
        hidden.sigmoid();

        Matrix output = Matrix.multiply(weights_ho, hidden, useMultiThreading);
        output.add(bias_o);
        output.sigmoid();

        Matrix target = Matrix.fromArray(Y);

        Matrix error = Matrix.subtract(target, output);
        Matrix gradient = output.dsigmoid();
        gradient.multiply(error);
        gradient.multiply(l_rate);

        if (showLoss)
            printLoss(error);

        Matrix hidden_T = Matrix.transpose(hidden);
        Matrix who_delta = Matrix.multiply(gradient, hidden_T, useMultiThreading);

        weights_ho.add(who_delta);
        bias_o.add(gradient);

        Matrix who_T = Matrix.transpose(weights_ho);
        Matrix hidden_errors = Matrix.multiply(who_T, error, useMultiThreading);

        Matrix h_gradient = hidden.dsigmoid();
        h_gradient.multiply(hidden_errors);
        h_gradient.multiply(l_rate);

        Matrix i_T = Matrix.transpose(input);
        Matrix wih_delta = Matrix.multiply(h_gradient, i_T, useMultiThreading);

        weights_ih.add(wih_delta);
        bias_h.add(h_gradient);
    }

    private void printLoss(Matrix error) {
        double avg = 0.0;

        for (int i = 0; i < error.rows; i++) {
            for (int j = 0; j < error.cols; j++) {
                avg += error.data[i][j];
            }
        }

        U.print("Average Error: " + avg + "\n");
    }
    
    public void testData(double[][] testing_in, double[][] testing_out) {
        int i = 0;
        List<Double> output;
        for (double d[] : testing_in) {
            output = predict(d);
            U.printf("Q: %s\nIn: %s\nOut: %s\nPrediction: %s\n",i,U.arrStr(d),U.arrStr(testing_out[i++]),output.toString());
        }
    }
    
    public double[][] getFileData(String fileName) {
        List<String> rawData = U.readFile(fileName);
        List<ArrayList> filteredData = new ArrayList<ArrayList>();

        for (String n : rawData) {
            String[] s = n.split(",");
            List<Double> temp = new ArrayList<Double>();
            for (String i : s) {
                temp.add(Double.parseDouble(i));
            }
            filteredData.add((ArrayList<Double>) temp);
        }
        
        double[][] dataArr = nestedListToNestedArr(filteredData);
        
        return dataArr;
    }
    
    private static double[][] nestedListToNestedArr(List<ArrayList> dataList) {
        double[][] dataArr = new double[dataList.size()][dataList.get(0).size()];
        int y = 0;
        for (List<ArrayList> n : dataList) {
            int x = 0;
            for (Object i : n) {
                dataArr[y][x] = ((Double) i);
                x++;
            }
            y++;
        }
        return dataArr;
    }
}

class Matrix {
    private static BasicUtils U = new BasicUtils();
    
    double[][] data;
    int rows, cols;

    public Matrix(int rows, int cols) {
        data = new double[rows][cols];
        this.rows = rows;
        this.cols = cols;
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                data[i][j] = Math.random() * 2 - 1;
            }
        }
    }

    public void print() {
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                U.print(this.data[i][j] + " ");
            }
            U.println("");
        }
    }

    public void add(int scaler) {
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                this.data[i][j] += scaler;
            }

        }
    }

    public void add(Matrix m) {
        if (cols != m.cols || rows != m.rows) {
            U.println("Shape Mismatch");
            return;
        }

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                this.data[i][j] += m.data[i][j];
            }
        }
    }

    public static Matrix fromArray(double[] x) {
        Matrix temp = new Matrix(x.length, 1);
        for (int i = 0; i < x.length; i++)
            temp.data[i][0] = x[i];
        return temp;
    }

    public List<Double> toArray() {
        List<Double> temp = new ArrayList<Double>();

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                temp.add(data[i][j]);
            }
        }
        return temp;
    }

    public static Matrix subtract(Matrix a, Matrix b) {
        Matrix temp = new Matrix(a.rows, a.cols);
        for (int i = 0; i < a.rows; i++) {
            for (int j = 0; j < a.cols; j++) {
                temp.data[i][j] = a.data[i][j] - b.data[i][j];
            }
        }
        return temp;
    }

    public static Matrix transpose(Matrix a) {
        Matrix temp = new Matrix(a.cols, a.rows);
        for (int i = 0; i < a.rows; i++) {
            for (int j = 0; j < a.cols; j++) {
                temp.data[j][i] = a.data[i][j];
            }
        }
        return temp;
    }

    // TODO Add Multi-threading
    public static Matrix multiply(Matrix a, Matrix b, boolean useMultiThreading) {
        Matrix temp = new Matrix(a.rows, b.cols);
        if (!useMultiThreading) {
            for (int i = 0; i < temp.rows; i++) {
                for (int j = 0; j < temp.cols; j++) {
                    double sum = 0;
                    for (int k = 0; k < a.cols; k++) {
                        sum += a.data[i][k] * b.data[k][j];
                    }
                    temp.data[i][j] = sum;
                }
            }

        } else {

            // return ParallelMatrixMultiplication.multiply(a, b);
            ParallelThreadsCreator.multiply(a, b, temp);

        }

        return temp;
    }

    public void multiply(Matrix a) {
        for (int i = 0; i < a.rows; i++) {
            for (int j = 0; j < a.cols; j++) {
                this.data[i][j] *= a.data[i][j];
            }
        }

    }

    public void multiply(double a) {
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                this.data[i][j] *= a;
            }
        }
    }

    public void sigmoid() {
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++)
                this.data[i][j] = 1 / (1 + Math.exp(-this.data[i][j]));
        }
    }

    public Matrix dsigmoid() {
        Matrix temp = new Matrix(rows, cols);
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++)
                temp.data[i][j] = this.data[i][j] * (1 - this.data[i][j]);
        }
        return temp;
    }
}

class ParallelThreadsCreator {

    // creating 10 threads and waiting for them to complete then again repeat steps.
    public static void multiply(Matrix matrix1, Matrix matrix2, Matrix result) {
        List<Thread> threads = new ArrayList<>();
        int rows1 = matrix1.rows;
        for (int i = 0; i < rows1; i++) {
            RowMultiplyWorker task = new RowMultiplyWorker(result, matrix1, matrix2, i);
            Thread thread = new Thread(task);
            thread.start();
            threads.add(thread);
            if (threads.size() % 10 == 0) {
                waitForThreads(threads);
            }
        }
    }

    private static void waitForThreads(List<Thread> threads) {
        for (Thread thread : threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        threads.clear();
    }
}

class WorkerThread extends Thread {
    private int row;
    private int col;
    private int[][] A;
    private int[][] B;
    private int[][] C;

    public WorkerThread(int row, int col, int[][] A, int[][] B, int[][] C) {
        this.row = row;
        this.col = col;
        this.A = A;
        this.B = B;
        this.C = C;
    }

    public void run() {
        C[row][col] = (A[row][0] * B[0][col]) + (A[row][1] * B[1][col]);
    }
}

class RowMultiplyWorker implements Runnable {
    private final Matrix result;
    private Matrix matrix1;
    private Matrix matrix2;
    private final int row;

    public RowMultiplyWorker(Matrix result, Matrix matrix1, Matrix matrix2, int row) {
        this.result = result;
        this.matrix1 = matrix1;
        this.matrix2 = matrix2;
        this.row = row;
    }

    @Override
    public void run() {

        for (int i = 0; i < matrix2.data[0].length; i++) {
            result.data[row][i] = 0;
            for (int j = 0; j < matrix1.data[row].length; j++) {
                result.data[row][i] += matrix1.data[row][j] * matrix2.data[j][i];
            }
        }
    }
}

final class BasicUtils {
    private static PrintWriter writer = new PrintWriter(System.out);
    
    public static List<String> readFile(String fileName) {
        List<String> out = new ArrayList<String>();
        try {
            File file = new File(fileName);
            Scanner reader = new Scanner(file);
            while (reader.hasNextLine()) {
                String data = reader.nextLine();
                out.add(data);
            }
            reader.close();
        } catch (FileNotFoundException e) {
            println("An error occurred.");
            e.printStackTrace();
        }
        
        return out;
    }
    
    public static String arrStr(double[] arr) {
        return Arrays.toString(arr);
    }
    
    public static void print(Object str) {
        writer.write(String.valueOf(str));
        writer.flush();
    }
    
    public static void println(Object str) {
        print(str+"\n");
    }
    
    public static void printf(Object mainText, Object... x) {
        String toPrint = "";
        
        String[] y = String.valueOf(mainText).split("%s");
        int i = 0;
        for (String n : y) {
            toPrint += n;
            if (i<x.length) {
                toPrint += x[i++];
            }
        }
        
        println(toPrint);
    }
}
